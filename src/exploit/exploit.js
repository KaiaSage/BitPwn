import sourceMap from 'source-map';
import moduleRaid from 'moduleraid';

async function createGlobals() {
  try {
    if (!globalThis.consumer) {
      const jsonData = await fetch('/dist/main.bundle.js.map').then((response) => response.json());
      const consumer = await new sourceMap.SourceMapConsumer(jsonData);
      consumer.computeColumnSpans();
      globalThis.consumer = consumer;
    }
  } catch (err) {
    console.log(err);
  }

  try {
    if (!globalThis.mR) {
      const mR = new moduleRaid({ entrypoint: 'webpackChunkbitburner' });
      globalThis.mR = mR;
    }
  } catch (err) {
    console.log(err);
  }

  try {
    if (!globalThis.bundleSrc) {
      globalThis.bundleSrc = await fetch('/dist/main.bundle.js')
        .then((response) => response.text())
        .then((str) => str.split('\n'));
    }
  } catch (err) {
    console.log(err);
  }
}

/**
 *
 * @param moduleString: string - A string used in the module, used to detect the right module.
 * A good choice is error messages, eg "Tried to launch a worker script on a different server".
 * If you don't have a string you can propbably find another way to do this.
 * @param sourcePath: string - The path to the typescript file in source, eg '/src/NetscriptWorker.ts'.
 * @param functionName: string - The (unminified) name of a bitburner function.
 * @returns The function, if found.
 */
export function getInternalFunction(moduleString, sourcePath, functionName) {
  sourcePath = 'webpack://' + sourcePath;
  if (!globalThis.consumer._names._array.includes(functionName)) {
    console.log(`Unknown name ${functionName}`);
  }

  // Scan the source map for the named module & function.
  const results = [];
  globalThis.consumer.eachMapping((mapping) => {
    if (mapping.source == sourcePath && mapping.name == functionName) {
      results.push(mapping);
    }
  });

  if (results.length == 0) {
    console.log(`No uses of function ${functionName} in module ${sourcePath}:`);
    return undefined;
  }
  console.log(`Usages of function ${functionName} in module ${sourcePath}:`);
  console.log(results);

  const col = results[0].generatedColumn;
  const line = results[0].generatedLine;

  // Look up the resulting code in the minified JS:
  // Since it's minified, 10 is hooopefully a safe bet?
  const funcMinifiedName = globalThis.bundleSrc[line - 1].slice(col, col + 10).split('(')[0];
  console.log(`Relevant usage: ${globalThis.bundleSrc[line - 1].slice(col - 10, col + 10)}`);
  console.log(`Found ${functionName} as ${funcMinifiedName}`);

  // Look for a module containing the specified string.
  const mod = globalThis.mR.findModule(moduleString)[0];
  console.log(`Found ${mod} as ${sourcePath}`);
  console.log('module: ', mod);

  for (const [key, value] of Object.entries(mod)) {
    console.log(key, value);
    if (value?.name && value.name == funcMinifiedName) {
      console.log(`FOUND ${functionName}`, value);
      return value;
    }
  }
  console.log('FAILED :(');
}

/**
 *
 * @param moduleString: string - A string used in the module, used to detect the right module.
 * A good choice is error messages, eg "Tried to launch a worker script on a different server".
 * If you don't have a string you can propbably find another way to do this.
 * @param knownMethod: string - A method in the class's prototype.
 */
export function getInternalClass(moduleString, knownMethod) {
  // Look for a module containing the specified string.
  const mod = globalThis.mR.findModule(moduleString)[0];
  console.log('Module: ', mod);

  for (const [key, value] of Object.entries(mod)) {
    console.log(key, value);
    if (value?.prototype[knownMethod]) {
      console.log(`FOUND ${value.name}`, value);
      return value;
    }
  }
  console.log('FAILED :(');
}

export async function main(ns) {
  await createGlobals();
  const GetServer = getInternalFunction(
    'Hostname of the server thats being added: ',
    '/src/Server/AllServers.ts',
    'GetServer',
  );
  const startWorkerScript = getInternalFunction(
    'Tried to launch a worker script on a different server ',
    '/src/NetscriptWorker.ts',
    'startWorkerScript',
  );
  const RunningScript = getInternalClass('Must provide a ramUsage for RunningScript initialization.', 'recordWeaken');
  console.log(RunningScript);

  const hostname = 'millenium-fitness';
  const script = 'test.js';
  ns.scp(script, hostname, 'home');
  const host = GetServer(hostname);
  const runningScript = new RunningScript(host.scripts.get(script), 1.6, []);
  const pid = startWorkerScript(runningScript, host);
}
